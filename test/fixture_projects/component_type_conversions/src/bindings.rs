// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Point {
    pub x: u32,
    pub y: u32,
}
impl ::core::fmt::Debug for Point {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Point").field("x", &self.x).field("y", &self.y).finish()
    }
}
#[repr(u8)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum EnumType {
    A,
    B,
    C,
}
impl ::core::fmt::Debug for EnumType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            EnumType::A => f.debug_tuple("EnumType::A").finish(),
            EnumType::B => f.debug_tuple("EnumType::B").finish(),
            EnumType::C => f.debug_tuple("EnumType::C").finish(),
        }
    }
}
impl EnumType {
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> EnumType {
        if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
        }
        match val {
            0 => EnumType::A,
            1 => EnumType::B,
            2 => EnumType::C,
            _ => panic!("invalid enum discriminant"),
        }
    }
}
#[derive(Clone)]
pub enum VariantType {
    None,
    Str(_rt::String),
    Int(u32),
    Float(f32),
    Boolean(bool),
    Point(Point),
    ListPoint(_rt::Vec<Point>),
    OptionU8(Option<u8>),
    EnumType(EnumType),
}
impl ::core::fmt::Debug for VariantType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            VariantType::None => f.debug_tuple("VariantType::None").finish(),
            VariantType::Str(e) => f.debug_tuple("VariantType::Str").field(e).finish(),
            VariantType::Int(e) => f.debug_tuple("VariantType::Int").field(e).finish(),
            VariantType::Float(e) => {
                f.debug_tuple("VariantType::Float").field(e).finish()
            }
            VariantType::Boolean(e) => {
                f.debug_tuple("VariantType::Boolean").field(e).finish()
            }
            VariantType::Point(e) => {
                f.debug_tuple("VariantType::Point").field(e).finish()
            }
            VariantType::ListPoint(e) => {
                f.debug_tuple("VariantType::ListPoint").field(e).finish()
            }
            VariantType::OptionU8(e) => {
                f.debug_tuple("VariantType::OptionU8").field(e).finish()
            }
            VariantType::EnumType(e) => {
                f.debug_tuple("VariantType::EnumType").field(e).finish()
            }
        }
    }
}
wit_bindgen_rt::bitflags::bitflags! {
    #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub struct
    Permission : u8 { const READ = 1 << 0; const WRITE = 1 << 1; const EXEC = 1 << 2; }
}
#[derive(Clone)]
pub struct ComplexType {
    pub str: _rt::String,
    pub int: u32,
    pub float: f32,
    pub boolean: bool,
    pub list_u8: _rt::Vec<u8>,
    pub list_point: _rt::Vec<Point>,
    pub option_u8: Option<u8>,
    pub option_string: Option<_rt::String>,
    pub option_point: Option<Point>,
    pub option_list_point: Option<_rt::Vec<Point>>,
    pub result_u8_string: Result<u8, _rt::String>,
    pub empty_result: Result<(), ()>,
    pub tuple_u8_point: (u8, Point),
}
impl ::core::fmt::Debug for ComplexType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ComplexType")
            .field("str", &self.str)
            .field("int", &self.int)
            .field("float", &self.float)
            .field("boolean", &self.boolean)
            .field("list-u8", &self.list_u8)
            .field("list-point", &self.list_point)
            .field("option-u8", &self.option_u8)
            .field("option-string", &self.option_string)
            .field("option-point", &self.option_point)
            .field("option-list-point", &self.option_list_point)
            .field("result-u8-string", &self.result_u8_string)
            .field("empty-result", &self.empty_result)
            .field("tuple-u8-point", &self.tuple_u8_point)
            .finish()
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_string(str: &str) -> _rt::String {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 2 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 2 * ::core::mem::size_of::<*const u8>()],
        );
        let vec0 = str;
        let ptr0 = vec0.as_ptr().cast::<u8>();
        let len0 = vec0.len();
        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-string"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
        let l3 = *ptr1.add(0).cast::<*mut u8>();
        let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
        let len5 = l4;
        let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
        let result6 = _rt::string_lift(bytes5);
        result6
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_u8(int: u8) -> u8 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-u8"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i32(&int)) };
        ret as u8
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_u16(int: u16) -> u16 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-u16"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i32(&int)) };
        ret as u16
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_u32(int: u32) -> u32 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-u32"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i32(&int)) };
        ret as u32
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_u64(int: u64) -> u64 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-u64"]
            fn wit_import0(_: i64) -> i64;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i64) -> i64 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i64(&int)) };
        ret as u64
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_s8(int: i8) -> i8 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-s8"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i32(&int)) };
        ret as i8
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_s16(int: i16) -> i16 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-s16"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i32(&int)) };
        ret as i16
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_s32(int: i32) -> i32 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-s32"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i32(&int)) };
        ret
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_s64(int: i64) -> i64 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-s64"]
            fn wit_import0(_: i64) -> i64;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i64) -> i64 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i64(&int)) };
        ret
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_f32(float: f32) -> f32 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-f32"]
            fn wit_import0(_: f32) -> f32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: f32) -> f32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_f32(&float)) };
        ret
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_f64(float: f64) -> f64 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-f64"]
            fn wit_import0(_: f64) -> f64;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: f64) -> f64 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_f64(&float)) };
        ret
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_bool(boolean: bool) -> bool {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-bool"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe {
            wit_import0(
                match &boolean {
                    true => 1,
                    false => 0,
                },
            )
        };
        _rt::bool_lift(ret as u8)
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_char(chr: char) -> char {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-char"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(_rt::as_i32(&chr)) };
        _rt::char_lift(ret as u32)
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_list_u8(l: &[u8]) -> _rt::Vec<u8> {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 2 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 2 * ::core::mem::size_of::<*const u8>()],
        );
        let vec0 = l;
        let ptr0 = vec0.as_ptr().cast::<u8>();
        let len0 = vec0.len();
        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-list-u8"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
        let l3 = *ptr1.add(0).cast::<*mut u8>();
        let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
        let len5 = l4;
        let result6 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
        result6
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_tuple_u8_string(t: (u8, &str)) -> (u8, _rt::String) {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
        );
        let (t0_0, t0_1) = t;
        let vec1 = t0_1;
        let ptr1 = vec1.as_ptr().cast::<u8>();
        let len1 = vec1.len();
        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-tuple-u8-string"]
            fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import3(_rt::as_i32(t0_0), ptr1.cast_mut(), len1, ptr2) };
        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
        let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l6 = *ptr2.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
        let len7 = l6;
        let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
        let result8 = (l4 as u8, _rt::string_lift(bytes7));
        result8
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_flags(f: Permission) -> Permission {
    unsafe {
        let flags0 = f;
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-flags"]
            fn wit_import1(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import1((flags0.bits() >> 0) as i32) };
        Permission::empty() | Permission::from_bits_retain(((ret as u8) << 0) as _)
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_variant(v: &VariantType) -> VariantType {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
        );
        let (result4_0, result4_1, result4_2) = match v {
            VariantType::None => (0i32, ::core::ptr::null_mut(), 0usize),
            VariantType::Str(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();
                (1i32, ptr0.cast_mut(), len0)
            }
            VariantType::Int(e) => (2i32, _rt::as_i32(e) as *mut u8, 0usize),
            VariantType::Float(e) => {
                (3i32, (_rt::as_f32(e)).to_bits() as i32 as *mut u8, 0usize)
            }
            VariantType::Boolean(e) => {
                (
                    4i32,
                    match e {
                        true => 1,
                        false => 0,
                    } as *mut u8,
                    0usize,
                )
            }
            VariantType::Point(e) => {
                let Point { x: x1, y: y1 } = e;
                (5i32, _rt::as_i32(x1) as *mut u8, _rt::as_i32(y1) as usize)
            }
            VariantType::ListPoint(e) => {
                let vec2 = e;
                let ptr2 = vec2.as_ptr().cast::<u8>();
                let len2 = vec2.len();
                (6i32, ptr2.cast_mut(), len2)
            }
            VariantType::OptionU8(e) => {
                let (result3_0, result3_1) = match e {
                    Some(e) => (1i32, _rt::as_i32(e)),
                    None => (0i32, 0i32),
                };
                (7i32, result3_0 as *mut u8, result3_1 as usize)
            }
            VariantType::EnumType(e) => (8i32, e.clone() as i32 as *mut u8, 0usize),
        };
        let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-variant"]
            fn wit_import6(_: i32, _: *mut u8, _: usize, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import6(_: i32, _: *mut u8, _: usize, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import6(result4_0, result4_1, result4_2, ptr5) };
        let l7 = i32::from(*ptr5.add(0).cast::<u8>());
        let v22 = match l7 {
            0 => VariantType::None,
            1 => {
                let e22 = {
                    let l8 = *ptr5
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *ptr5
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len10 = l9;
                    let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                    _rt::string_lift(bytes10)
                };
                VariantType::Str(e22)
            }
            2 => {
                let e22 = {
                    let l11 = *ptr5
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    l11 as u32
                };
                VariantType::Int(e22)
            }
            3 => {
                let e22 = {
                    let l12 = *ptr5
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<f32>();
                    l12
                };
                VariantType::Float(e22)
            }
            4 => {
                let e22 = {
                    let l13 = i32::from(
                        *ptr5.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    _rt::bool_lift(l13 as u8)
                };
                VariantType::Boolean(e22)
            }
            5 => {
                let e22 = {
                    let l14 = *ptr5
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l15 = *ptr5
                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    Point {
                        x: l14 as u32,
                        y: l15 as u32,
                    }
                };
                VariantType::Point(e22)
            }
            6 => {
                let e22 = {
                    let l16 = *ptr5
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l17 = *ptr5
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len18 = l17;
                    _rt::Vec::from_raw_parts(l16.cast(), len18, len18)
                };
                VariantType::ListPoint(e22)
            }
            7 => {
                let e22 = {
                    let l19 = i32::from(
                        *ptr5.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l19 {
                        0 => None,
                        1 => {
                            let e = {
                                let l20 = i32::from(
                                    *ptr5
                                        .add(1 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                l20 as u8
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                };
                VariantType::OptionU8(e22)
            }
            n => {
                debug_assert_eq!(n, 8, "invalid enum discriminant");
                let e22 = {
                    let l21 = i32::from(
                        *ptr5.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    EnumType::_lift(l21 as u8)
                };
                VariantType::EnumType(e22)
            }
        };
        let result23 = v22;
        result23
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_enum(e: EnumType) -> EnumType {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-enum"]
            fn wit_import0(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import0(e.clone() as i32) };
        EnumType::_lift(ret as u8)
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_point(p: Point) -> Point {
    unsafe {
        #[repr(align(4))]
        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
        let Point { x: x0, y: y0 } = p;
        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-point"]
            fn wit_import2(_: i32, _: i32, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import2(_: i32, _: i32, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import2(_rt::as_i32(x0), _rt::as_i32(y0), ptr1) };
        let l3 = *ptr1.add(0).cast::<i32>();
        let l4 = *ptr1.add(4).cast::<i32>();
        let result5 = Point {
            x: l3 as u32,
            y: l4 as u32,
        };
        result5
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_option_u8(o: Option<u8>) -> Option<u8> {
    unsafe {
        #[repr(align(1))]
        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
        let (result0_0, result0_1) = match o {
            Some(e) => (1i32, _rt::as_i32(e)),
            None => (0i32, 0i32),
        };
        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-option-u8"]
            fn wit_import2(_: i32, _: i32, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import2(_: i32, _: i32, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import2(result0_0, result0_1, ptr1) };
        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
        let result5 = match l3 {
            0 => None,
            1 => {
                let e = {
                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                    l4 as u8
                };
                Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        };
        result5
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_result_u8_string(r: Result<u8, &str>) -> Result<u8, _rt::String> {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
        );
        let (result1_0, result1_1, result1_2) = match r {
            Ok(e) => (0i32, _rt::as_i32(e) as *mut u8, 0usize),
            Err(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();
                (1i32, ptr0.cast_mut(), len0)
            }
        };
        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-result-u8-string"]
            fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import3(result1_0, result1_1, result1_2, ptr2) };
        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
        let result9 = match l4 {
            0 => {
                let e = {
                    let l5 = i32::from(
                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    l5 as u8
                };
                Ok(e)
            }
            1 => {
                let e = {
                    let l6 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    _rt::string_lift(bytes8)
                };
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        };
        result9
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_result_u8_none(r: Result<u8, ()>) -> Result<u8, ()> {
    unsafe {
        #[repr(align(1))]
        struct RetArea([::core::mem::MaybeUninit<u8>; 2]);
        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
        let (result0_0, result0_1) = match r {
            Ok(e) => (0i32, _rt::as_i32(e)),
            Err(_) => (1i32, 0i32),
        };
        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-result-u8-none"]
            fn wit_import2(_: i32, _: i32, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import2(_: i32, _: i32, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import2(result0_0, result0_1, ptr1) };
        let l3 = i32::from(*ptr1.add(0).cast::<u8>());
        let result5 = match l3 {
            0 => {
                let e = {
                    let l4 = i32::from(*ptr1.add(1).cast::<u8>());
                    l4 as u8
                };
                Ok(e)
            }
            1 => {
                let e = ();
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        };
        result5
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_result_none_string(r: Result<(), &str>) -> Result<(), _rt::String> {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
        );
        let (result1_0, result1_1, result1_2) = match r {
            Ok(_) => (0i32, ::core::ptr::null_mut(), 0usize),
            Err(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();
                (1i32, ptr0.cast_mut(), len0)
            }
        };
        let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-result-none-string"]
            fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import3(_: i32, _: *mut u8, _: usize, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import3(result1_0, result1_1, result1_2, ptr2) };
        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
        let result8 = match l4 {
            0 => {
                let e = ();
                Ok(e)
            }
            1 => {
                let e = {
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l6 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    _rt::string_lift(bytes7)
                };
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        };
        result8
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_result_none_none(r: Result<(), ()>) -> Result<(), ()> {
    unsafe {
        let result0 = match r {
            Ok(_) => 0i32,
            Err(_) => 1i32,
        };
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-result-none-none"]
            fn wit_import1(_: i32) -> i32;
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: i32) -> i32 {
            unreachable!()
        }
        let ret = unsafe { wit_import1(result0) };
        match ret {
            0 => {
                let e = ();
                Ok(e)
            }
            1 => {
                let e = ();
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        }
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn import_id_record_complex(r: &ComplexType) -> ComplexType {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 32 + 18 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 32
                + 18 * ::core::mem::size_of::<*const u8>()],
        );
        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
        let ComplexType {
            str: str1,
            int: int1,
            float: float1,
            boolean: boolean1,
            list_u8: list_u81,
            list_point: list_point1,
            option_u8: option_u81,
            option_string: option_string1,
            option_point: option_point1,
            option_list_point: option_list_point1,
            result_u8_string: result_u8_string1,
            empty_result: empty_result1,
            tuple_u8_point: tuple_u8_point1,
        } = r;
        let vec2 = str1;
        let ptr2 = vec2.as_ptr().cast::<u8>();
        let len2 = vec2.len();
        *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
        *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
        *ptr0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
            int1,
        );
        *ptr0.add(4 + 2 * ::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(
            float1,
        );
        *ptr0.add(8 + 2 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (match boolean1 {
            true => 1,
            false => 0,
        }) as u8;
        let vec3 = list_u81;
        let ptr3 = vec3.as_ptr().cast::<u8>();
        let len3 = vec3.len();
        *ptr0.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
        *ptr0.add(8 + 3 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3
            .cast_mut();
        let vec4 = list_point1;
        let ptr4 = vec4.as_ptr().cast::<u8>();
        let len4 = vec4.len();
        *ptr0.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
        *ptr0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4
            .cast_mut();
        match option_u81 {
            Some(e) => {
                *ptr0.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                    as u8;
                *ptr0.add(9 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(
                    e,
                )) as u8;
            }
            None => {
                *ptr0.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                    as u8;
            }
        };
        match option_string1 {
            Some(e) => {
                *ptr0.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                    as u8;
                let vec5 = e;
                let ptr5 = vec5.as_ptr().cast::<u8>();
                let len5 = vec5.len();
                *ptr0
                    .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len5;
                *ptr0
                    .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>() = ptr5.cast_mut();
            }
            None => {
                *ptr0.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                    as u8;
            }
        };
        match option_point1 {
            Some(e) => {
                *ptr0.add(8 + 11 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                    as u8;
                let Point { x: x6, y: y6 } = e;
                *ptr0.add(12 + 11 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                    x6,
                );
                *ptr0.add(16 + 11 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                    y6,
                );
            }
            None => {
                *ptr0.add(8 + 11 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                    as u8;
            }
        };
        match option_list_point1 {
            Some(e) => {
                *ptr0.add(16 + 12 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                    as u8;
                let vec7 = e;
                let ptr7 = vec7.as_ptr().cast::<u8>();
                let len7 = vec7.len();
                *ptr0
                    .add(16 + 14 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len7;
                *ptr0
                    .add(16 + 13 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>() = ptr7.cast_mut();
            }
            None => {
                *ptr0.add(16 + 12 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                    as u8;
            }
        };
        match result_u8_string1 {
            Ok(e) => {
                *ptr0.add(16 + 15 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                    as u8;
                *ptr0.add(16 + 16 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(
                    e,
                )) as u8;
            }
            Err(e) => {
                *ptr0.add(16 + 15 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                    as u8;
                let vec8 = e;
                let ptr8 = vec8.as_ptr().cast::<u8>();
                let len8 = vec8.len();
                *ptr0
                    .add(16 + 17 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len8;
                *ptr0
                    .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>() = ptr8.cast_mut();
            }
        };
        match empty_result1 {
            Ok(_) => {
                *ptr0.add(16 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                    as u8;
            }
            Err(_) => {
                *ptr0.add(16 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                    as u8;
            }
        };
        let (t9_0, t9_1) = tuple_u8_point1;
        *ptr0.add(20 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(
            t9_0,
        )) as u8;
        let Point { x: x10, y: y10 } = t9_1;
        *ptr0.add(24 + 18 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
            x10,
        );
        *ptr0.add(28 + 18 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
            y10,
        );
        let ptr11 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "import-id-record-complex"]
            fn wit_import12(_: *mut u8, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import12(_: *mut u8, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import12(ptr0, ptr11) };
        let l13 = *ptr11.add(0).cast::<*mut u8>();
        let l14 = *ptr11.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
        let len15 = l14;
        let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);
        let l16 = *ptr11.add(2 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
        let l17 = *ptr11.add(4 + 2 * ::core::mem::size_of::<*const u8>()).cast::<f32>();
        let l18 = i32::from(
            *ptr11.add(8 + 2 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l19 = *ptr11
            .add(8 + 3 * ::core::mem::size_of::<*const u8>())
            .cast::<*mut u8>();
        let l20 = *ptr11
            .add(8 + 4 * ::core::mem::size_of::<*const u8>())
            .cast::<usize>();
        let len21 = l20;
        let l22 = *ptr11
            .add(8 + 5 * ::core::mem::size_of::<*const u8>())
            .cast::<*mut u8>();
        let l23 = *ptr11
            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
            .cast::<usize>();
        let len24 = l23;
        let l25 = i32::from(
            *ptr11.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l27 = i32::from(
            *ptr11.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l31 = i32::from(
            *ptr11.add(8 + 11 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l34 = i32::from(
            *ptr11.add(16 + 12 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l38 = i32::from(
            *ptr11.add(16 + 15 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l43 = i32::from(
            *ptr11.add(16 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l44 = i32::from(
            *ptr11.add(20 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let l45 = *ptr11
            .add(24 + 18 * ::core::mem::size_of::<*const u8>())
            .cast::<i32>();
        let l46 = *ptr11
            .add(28 + 18 * ::core::mem::size_of::<*const u8>())
            .cast::<i32>();
        let result47 = ComplexType {
            str: _rt::string_lift(bytes15),
            int: l16 as u32,
            float: l17,
            boolean: _rt::bool_lift(l18 as u8),
            list_u8: _rt::Vec::from_raw_parts(l19.cast(), len21, len21),
            list_point: _rt::Vec::from_raw_parts(l22.cast(), len24, len24),
            option_u8: match l25 {
                0 => None,
                1 => {
                    let e = {
                        let l26 = i32::from(
                            *ptr11
                                .add(9 + 7 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>(),
                        );
                        l26 as u8
                    };
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            },
            option_string: match l27 {
                0 => None,
                1 => {
                    let e = {
                        let l28 = *ptr11
                            .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l29 = *ptr11
                            .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len30 = l29;
                        let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);
                        _rt::string_lift(bytes30)
                    };
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            },
            option_point: match l31 {
                0 => None,
                1 => {
                    let e = {
                        let l32 = *ptr11
                            .add(12 + 11 * ::core::mem::size_of::<*const u8>())
                            .cast::<i32>();
                        let l33 = *ptr11
                            .add(16 + 11 * ::core::mem::size_of::<*const u8>())
                            .cast::<i32>();
                        Point {
                            x: l32 as u32,
                            y: l33 as u32,
                        }
                    };
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            },
            option_list_point: match l34 {
                0 => None,
                1 => {
                    let e = {
                        let l35 = *ptr11
                            .add(16 + 13 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l36 = *ptr11
                            .add(16 + 14 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len37 = l36;
                        _rt::Vec::from_raw_parts(l35.cast(), len37, len37)
                    };
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            },
            result_u8_string: match l38 {
                0 => {
                    let e = {
                        let l39 = i32::from(
                            *ptr11
                                .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>(),
                        );
                        l39 as u8
                    };
                    Ok(e)
                }
                1 => {
                    let e = {
                        let l40 = *ptr11
                            .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l41 = *ptr11
                            .add(16 + 17 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len42 = l41;
                        let bytes42 = _rt::Vec::from_raw_parts(l40.cast(), len42, len42);
                        _rt::string_lift(bytes42)
                    };
                    Err(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            },
            empty_result: match l43 {
                0 => {
                    let e = ();
                    Ok(e)
                }
                1 => {
                    let e = ();
                    Err(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            },
            tuple_u8_point: (
                l44 as u8,
                Point {
                    x: l45 as u32,
                    y: l46 as u32,
                },
            ),
        };
        result47
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_string_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let result1 = T::export_id_string(_rt::string_lift(bytes0));
    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
    let vec3 = (result1.into_bytes()).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_export_id_string<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l0, l1, 1);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_u8_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_u8(arg0 as u8);
    _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_u16_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_u16(arg0 as u16);
    _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_u32_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_u32(arg0 as u32);
    _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_u64_cabi<T: Guest>(arg0: i64) -> i64 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_u64(arg0 as u64);
    _rt::as_i64(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_s8_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_s8(arg0 as i8);
    _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_s16_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_s16(arg0 as i16);
    _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_s32_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_s32(arg0);
    _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_s64_cabi<T: Guest>(arg0: i64) -> i64 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_s64(arg0);
    _rt::as_i64(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_f32_cabi<T: Guest>(arg0: f32) -> f32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_f32(arg0);
    _rt::as_f32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_f64_cabi<T: Guest>(arg0: f64) -> f64 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_f64(arg0);
    _rt::as_f64(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_bool_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_bool(_rt::bool_lift(arg0 as u8));
    match result0 {
        true => 1,
        false => 0,
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_char_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_char(_rt::char_lift(arg0 as u32));
    _rt::as_i32(result0)
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_list_u8_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let result1 = T::export_id_list_u8(
        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
    );
    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
    let vec3 = (result1).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_export_id_list_u8<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base2 = l0;
    let len2 = l1;
    _rt::cabi_dealloc(base2, len2 * 1, 1);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_tuple_u8_string_cabi<T: Guest>(
    arg0: i32,
    arg1: *mut u8,
    arg2: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg2;
    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
    let result1 = T::export_id_tuple_u8_string((arg0 as u8, _rt::string_lift(bytes0)));
    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
    let (t3_0, t3_1) = result1;
    *ptr2.add(0).cast::<u8>() = (_rt::as_i32(t3_0)) as u8;
    let vec4 = (t3_1.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *ptr2.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_export_id_tuple_u8_string<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l1 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l0, l1, 1);
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_flags_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_flags(
        Permission::empty() | Permission::from_bits_retain(((arg0 as u8) << 0) as _),
    );
    let flags1 = result0;
    (flags1.bits() >> 0) as i32
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_variant_cabi<T: Guest>(
    arg0: i32,
    arg1: *mut u8,
    arg2: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let v2 = match arg0 {
        0 => VariantType::None,
        1 => {
            let e2 = {
                let len0 = arg2;
                let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                _rt::string_lift(bytes0)
            };
            VariantType::Str(e2)
        }
        2 => {
            let e2 = arg1 as i32 as u32;
            VariantType::Int(e2)
        }
        3 => {
            let e2 = f32::from_bits(arg1 as i32 as u32);
            VariantType::Float(e2)
        }
        4 => {
            let e2 = _rt::bool_lift(arg1 as i32 as u8);
            VariantType::Boolean(e2)
        }
        5 => {
            let e2 = Point {
                x: arg1 as i32 as u32,
                y: arg2 as i32 as u32,
            };
            VariantType::Point(e2)
        }
        6 => {
            let e2 = {
                let len1 = arg2;
                _rt::Vec::from_raw_parts(arg1.cast(), len1, len1)
            };
            VariantType::ListPoint(e2)
        }
        7 => {
            let e2 = match arg1 as i32 {
                0 => None,
                1 => {
                    let e = arg2 as i32 as u8;
                    Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
            };
            VariantType::OptionU8(e2)
        }
        n => {
            debug_assert_eq!(n, 8, "invalid enum discriminant");
            let e2 = EnumType::_lift(arg1 as i32 as u8);
            VariantType::EnumType(e2)
        }
    };
    let result3 = T::export_id_variant(v2);
    let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result3 {
        VariantType::None => {
            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
        }
        VariantType::Str(e) => {
            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
            let vec5 = (e.into_bytes()).into_boxed_slice();
            let ptr5 = vec5.as_ptr().cast::<u8>();
            let len5 = vec5.len();
            ::core::mem::forget(vec5);
            *ptr4.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
            *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5
                .cast_mut();
        }
        VariantType::Int(e) => {
            *ptr4.add(0).cast::<u8>() = (2i32) as u8;
            *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                e,
            );
        }
        VariantType::Float(e) => {
            *ptr4.add(0).cast::<u8>() = (3i32) as u8;
            *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(
                e,
            );
        }
        VariantType::Boolean(e) => {
            *ptr4.add(0).cast::<u8>() = (4i32) as u8;
            *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e {
                true => 1,
                false => 0,
            }) as u8;
        }
        VariantType::Point(e) => {
            *ptr4.add(0).cast::<u8>() = (5i32) as u8;
            let Point { x: x6, y: y6 } = e;
            *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                x6,
            );
            *ptr4.add(4 + 1 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                y6,
            );
        }
        VariantType::ListPoint(e) => {
            *ptr4.add(0).cast::<u8>() = (6i32) as u8;
            let vec7 = (e).into_boxed_slice();
            let ptr7 = vec7.as_ptr().cast::<u8>();
            let len7 = vec7.len();
            ::core::mem::forget(vec7);
            *ptr4.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
            *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7
                .cast_mut();
        }
        VariantType::OptionU8(e) => {
            *ptr4.add(0).cast::<u8>() = (7i32) as u8;
            match e {
                Some(e) => {
                    *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    *ptr4
                        .add(1 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (_rt::as_i32(e)) as u8;
                }
                None => {
                    *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                }
            };
        }
        VariantType::EnumType(e) => {
            *ptr4.add(0).cast::<u8>() = (8i32) as u8;
            *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone()
                as i32) as u8;
        }
    }
    ptr4
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_export_id_variant<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {}
        1 => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
        }
        2 => {}
        3 => {}
        4 => {}
        5 => {}
        6 => {
            let l3 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l4 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base5 = l3;
            let len5 = l4;
            _rt::cabi_dealloc(base5, len5 * 8, 4);
        }
        7 => {}
        _ => {}
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_enum_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_enum(EnumType::_lift(arg0 as u8));
    result0.clone() as i32
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_point_cabi<T: Guest>(arg0: i32, arg1: i32) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_point(Point {
        x: arg0 as u32,
        y: arg1 as u32,
    });
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    let Point { x: x2, y: y2 } = result0;
    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_option_u8_cabi<T: Guest>(
    arg0: i32,
    arg1: i32,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_option_u8(
        match arg0 {
            0 => None,
            1 => {
                let e = arg1 as u8;
                Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
    );
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result0 {
        Some(e) => {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
            *ptr1.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
        }
        None => {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_result_u8_string_cabi<T: Guest>(
    arg0: i32,
    arg1: *mut u8,
    arg2: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result1 = T::export_id_result_u8_string(
        match arg0 {
            0 => {
                let e = arg1 as i32 as u8;
                Ok(e)
            }
            1 => {
                let e = {
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    _rt::string_lift(bytes0)
                };
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
    );
    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result1 {
        Ok(e) => {
            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(
                e,
            )) as u8;
        }
        Err(e) => {
            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
            let vec3 = (e.into_bytes()).into_boxed_slice();
            let ptr3 = vec3.as_ptr().cast::<u8>();
            let len3 = vec3.len();
            ::core::mem::forget(vec3);
            *ptr2.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3
                .cast_mut();
        }
    };
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_export_id_result_u8_string<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {}
        _ => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_result_u8_none_cabi<T: Guest>(
    arg0: i32,
    arg1: i32,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_result_u8_none(
        match arg0 {
            0 => {
                let e = arg1 as u8;
                Ok(e)
            }
            1 => {
                let e = ();
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
    );
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result0 {
        Ok(e) => {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
            *ptr1.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
        }
        Err(_) => {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_result_none_string_cabi<T: Guest>(
    arg0: i32,
    arg1: *mut u8,
    arg2: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result1 = T::export_id_result_none_string(
        match arg0 {
            0 => {
                let e = ();
                Ok(e)
            }
            1 => {
                let e = {
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    _rt::string_lift(bytes0)
                };
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
    );
    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result1 {
        Ok(_) => {
            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
        }
        Err(e) => {
            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
            let vec3 = (e.into_bytes()).into_boxed_slice();
            let ptr3 = vec3.as_ptr().cast::<u8>();
            let len3 = vec3.len();
            ::core::mem::forget(vec3);
            *ptr2.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3
                .cast_mut();
        }
    };
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_export_id_result_none_string<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {}
        _ => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_result_none_none_cabi<T: Guest>(arg0: i32) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::export_id_result_none_none(
        match arg0 {
            0 => {
                let e = ();
                Ok(e)
            }
            1 => {
                let e = ();
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
    );
    let result1 = match result0 {
        Ok(_) => 0i32,
        Err(_) => 1i32,
    };
    result1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_export_id_record_complex_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    let len2 = l1;
    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
    let l3 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
    let l4 = *arg0.add(4 + 2 * ::core::mem::size_of::<*const u8>()).cast::<f32>();
    let l5 = i32::from(
        *arg0.add(8 + 2 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l6 = *arg0.add(8 + 3 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l7 = *arg0.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let len8 = l7;
    let l9 = *arg0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l10 = *arg0.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let len11 = l10;
    let l12 = i32::from(
        *arg0.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l14 = i32::from(
        *arg0.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l18 = i32::from(
        *arg0.add(8 + 11 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l21 = i32::from(
        *arg0.add(16 + 12 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l25 = i32::from(
        *arg0.add(16 + 15 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l30 = i32::from(
        *arg0.add(16 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l31 = i32::from(
        *arg0.add(20 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    let l32 = *arg0.add(24 + 18 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
    let l33 = *arg0.add(28 + 18 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
    let result34 = T::export_id_record_complex(ComplexType {
        str: _rt::string_lift(bytes2),
        int: l3 as u32,
        float: l4,
        boolean: _rt::bool_lift(l5 as u8),
        list_u8: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
        list_point: _rt::Vec::from_raw_parts(l9.cast(), len11, len11),
        option_u8: match l12 {
            0 => None,
            1 => {
                let e = {
                    let l13 = i32::from(
                        *arg0
                            .add(9 + 7 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    l13 as u8
                };
                Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
        option_string: match l14 {
            0 => None,
            1 => {
                let e = {
                    let l15 = *arg0
                        .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l16 = *arg0
                        .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len17 = l16;
                    let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);
                    _rt::string_lift(bytes17)
                };
                Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
        option_point: match l18 {
            0 => None,
            1 => {
                let e = {
                    let l19 = *arg0
                        .add(12 + 11 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l20 = *arg0
                        .add(16 + 11 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    Point {
                        x: l19 as u32,
                        y: l20 as u32,
                    }
                };
                Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
        option_list_point: match l21 {
            0 => None,
            1 => {
                let e = {
                    let l22 = *arg0
                        .add(16 + 13 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l23 = *arg0
                        .add(16 + 14 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len24 = l23;
                    _rt::Vec::from_raw_parts(l22.cast(), len24, len24)
                };
                Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
        result_u8_string: match l25 {
            0 => {
                let e = {
                    let l26 = i32::from(
                        *arg0
                            .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    l26 as u8
                };
                Ok(e)
            }
            1 => {
                let e = {
                    let l27 = *arg0
                        .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l28 = *arg0
                        .add(16 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len29 = l28;
                    let bytes29 = _rt::Vec::from_raw_parts(l27.cast(), len29, len29);
                    _rt::string_lift(bytes29)
                };
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
        empty_result: match l30 {
            0 => {
                let e = ();
                Ok(e)
            }
            1 => {
                let e = ();
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        },
        tuple_u8_point: (
            l31 as u8,
            Point {
                x: l32 as u32,
                y: l33 as u32,
            },
        ),
    });
    _rt::cabi_dealloc(
        arg0,
        32 + 18 * ::core::mem::size_of::<*const u8>(),
        ::core::mem::size_of::<*const u8>(),
    );
    let ptr35 = (&raw mut _RET_AREA.0).cast::<u8>();
    let ComplexType {
        str: str36,
        int: int36,
        float: float36,
        boolean: boolean36,
        list_u8: list_u836,
        list_point: list_point36,
        option_u8: option_u836,
        option_string: option_string36,
        option_point: option_point36,
        option_list_point: option_list_point36,
        result_u8_string: result_u8_string36,
        empty_result: empty_result36,
        tuple_u8_point: tuple_u8_point36,
    } = result34;
    let vec37 = (str36.into_bytes()).into_boxed_slice();
    let ptr37 = vec37.as_ptr().cast::<u8>();
    let len37 = vec37.len();
    ::core::mem::forget(vec37);
    *ptr35.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len37;
    *ptr35.add(0).cast::<*mut u8>() = ptr37.cast_mut();
    *ptr35.add(2 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
        int36,
    );
    *ptr35.add(4 + 2 * ::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(
        float36,
    );
    *ptr35.add(8 + 2 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (match boolean36 {
        true => 1,
        false => 0,
    }) as u8;
    let vec38 = (list_u836).into_boxed_slice();
    let ptr38 = vec38.as_ptr().cast::<u8>();
    let len38 = vec38.len();
    ::core::mem::forget(vec38);
    *ptr35.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len38;
    *ptr35.add(8 + 3 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr38
        .cast_mut();
    let vec39 = (list_point36).into_boxed_slice();
    let ptr39 = vec39.as_ptr().cast::<u8>();
    let len39 = vec39.len();
    ::core::mem::forget(vec39);
    *ptr35.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len39;
    *ptr35.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr39
        .cast_mut();
    match option_u836 {
        Some(e) => {
            *ptr35.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            *ptr35.add(9 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(
                e,
            )) as u8;
        }
        None => {
            *ptr35.add(8 + 7 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    match option_string36 {
        Some(e) => {
            *ptr35.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            let vec40 = (e.into_bytes()).into_boxed_slice();
            let ptr40 = vec40.as_ptr().cast::<u8>();
            let len40 = vec40.len();
            ::core::mem::forget(vec40);
            *ptr35.add(8 + 10 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len40;
            *ptr35.add(8 + 9 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr40
                .cast_mut();
        }
        None => {
            *ptr35.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    match option_point36 {
        Some(e) => {
            *ptr35.add(8 + 11 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            let Point { x: x41, y: y41 } = e;
            *ptr35.add(12 + 11 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                x41,
            );
            *ptr35.add(16 + 11 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                y41,
            );
        }
        None => {
            *ptr35.add(8 + 11 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    match option_list_point36 {
        Some(e) => {
            *ptr35.add(16 + 12 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            let vec42 = (e).into_boxed_slice();
            let ptr42 = vec42.as_ptr().cast::<u8>();
            let len42 = vec42.len();
            ::core::mem::forget(vec42);
            *ptr35.add(16 + 14 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len42;
            *ptr35
                .add(16 + 13 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>() = ptr42.cast_mut();
        }
        None => {
            *ptr35.add(16 + 12 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    match result_u8_string36 {
        Ok(e) => {
            *ptr35.add(16 + 15 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
            *ptr35.add(16 + 16 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(
                e,
            )) as u8;
        }
        Err(e) => {
            *ptr35.add(16 + 15 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            let vec43 = (e.into_bytes()).into_boxed_slice();
            let ptr43 = vec43.as_ptr().cast::<u8>();
            let len43 = vec43.len();
            ::core::mem::forget(vec43);
            *ptr35.add(16 + 17 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len43;
            *ptr35
                .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>() = ptr43.cast_mut();
        }
    };
    match empty_result36 {
        Ok(_) => {
            *ptr35.add(16 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
        Err(_) => {
            *ptr35.add(16 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
        }
    };
    let (t44_0, t44_1) = tuple_u8_point36;
    *ptr35.add(20 + 18 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (_rt::as_i32(
        t44_0,
    )) as u8;
    let Point { x: x45, y: y45 } = t44_1;
    *ptr35.add(24 + 18 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
        x45,
    );
    *ptr35.add(28 + 18 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
        y45,
    );
    ptr35
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_export_id_record_complex<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l0, l1, 1);
    let l2 = *arg0.add(8 + 3 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l3 = *arg0.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base4 = l2;
    let len4 = l3;
    _rt::cabi_dealloc(base4, len4 * 1, 1);
    let l5 = *arg0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l6 = *arg0.add(8 + 6 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base7 = l5;
    let len7 = l6;
    _rt::cabi_dealloc(base7, len7 * 8, 4);
    let l8 = i32::from(
        *arg0.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    match l8 {
        0 => {}
        _ => {
            let l9 = *arg0
                .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l10 = *arg0
                .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l9, l10, 1);
        }
    }
    let l11 = i32::from(
        *arg0.add(16 + 12 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    match l11 {
        0 => {}
        _ => {
            let l12 = *arg0
                .add(16 + 13 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l13 = *arg0
                .add(16 + 14 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base14 = l12;
            let len14 = l13;
            _rt::cabi_dealloc(base14, len14 * 8, 4);
        }
    }
    let l15 = i32::from(
        *arg0.add(16 + 15 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    match l15 {
        0 => {}
        _ => {
            let l16 = *arg0
                .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l17 = *arg0
                .add(16 + 17 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l16, l17, 1);
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_random_bytes_cabi<T: Guest>(arg0: i32) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::get_random_bytes(arg0 as u32);
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    let vec2 = (result0).into_boxed_slice();
    let ptr2 = vec2.as_ptr().cast::<u8>();
    let len2 = vec2.len();
    ::core::mem::forget(vec2);
    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_random_bytes<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base2 = l0;
    let len2 = l1;
    _rt::cabi_dealloc(base2, len2 * 1, 1);
}
pub trait Guest {
    fn export_id_string(str: _rt::String) -> _rt::String;
    fn export_id_u8(int: u8) -> u8;
    fn export_id_u16(int: u16) -> u16;
    fn export_id_u32(int: u32) -> u32;
    fn export_id_u64(int: u64) -> u64;
    fn export_id_s8(int: i8) -> i8;
    fn export_id_s16(int: i16) -> i16;
    fn export_id_s32(int: i32) -> i32;
    fn export_id_s64(int: i64) -> i64;
    fn export_id_f32(float: f32) -> f32;
    fn export_id_f64(float: f64) -> f64;
    fn export_id_bool(boolean: bool) -> bool;
    fn export_id_char(chr: char) -> char;
    fn export_id_list_u8(l: _rt::Vec<u8>) -> _rt::Vec<u8>;
    fn export_id_tuple_u8_string(t: (u8, _rt::String)) -> (u8, _rt::String);
    fn export_id_flags(f: Permission) -> Permission;
    fn export_id_variant(v: VariantType) -> VariantType;
    fn export_id_enum(e: EnumType) -> EnumType;
    fn export_id_point(p: Point) -> Point;
    fn export_id_option_u8(o: Option<u8>) -> Option<u8>;
    fn export_id_result_u8_string(r: Result<u8, _rt::String>) -> Result<u8, _rt::String>;
    fn export_id_result_u8_none(r: Result<u8, ()>) -> Result<u8, ()>;
    fn export_id_result_none_string(
        r: Result<(), _rt::String>,
    ) -> Result<(), _rt::String>;
    fn export_id_result_none_none(r: Result<(), ()>) -> Result<(), ()>;
    fn export_id_record_complex(r: ComplexType) -> ComplexType;
    fn get_random_bytes(len: u32) -> _rt::Vec<u8>;
}
#[doc(hidden)]
macro_rules! __export_world_root_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "export-id-string")] unsafe extern "C"
        fn export_export_id_string(arg0 : * mut u8, arg1 : usize,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_export_id_string_cabi::<$ty > (arg0, arg1) } }
        #[unsafe (export_name = "cabi_post_export-id-string")] unsafe extern "C" fn
        _post_return_export_id_string(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_export_id_string::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-u8")] unsafe extern "C" fn export_export_id_u8(arg0 : i32,) -> i32 {
        unsafe { $($path_to_types)*:: _export_export_id_u8_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-u16")] unsafe extern "C" fn
        export_export_id_u16(arg0 : i32,) -> i32 { unsafe { $($path_to_types)*::
        _export_export_id_u16_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-u32")] unsafe extern "C" fn export_export_id_u32(arg0 : i32,) -> i32 {
        unsafe { $($path_to_types)*:: _export_export_id_u32_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-u64")] unsafe extern "C" fn
        export_export_id_u64(arg0 : i64,) -> i64 { unsafe { $($path_to_types)*::
        _export_export_id_u64_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-s8")] unsafe extern "C" fn export_export_id_s8(arg0 : i32,) -> i32 {
        unsafe { $($path_to_types)*:: _export_export_id_s8_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-s16")] unsafe extern "C" fn
        export_export_id_s16(arg0 : i32,) -> i32 { unsafe { $($path_to_types)*::
        _export_export_id_s16_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-s32")] unsafe extern "C" fn export_export_id_s32(arg0 : i32,) -> i32 {
        unsafe { $($path_to_types)*:: _export_export_id_s32_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-s64")] unsafe extern "C" fn
        export_export_id_s64(arg0 : i64,) -> i64 { unsafe { $($path_to_types)*::
        _export_export_id_s64_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-f32")] unsafe extern "C" fn export_export_id_f32(arg0 : f32,) -> f32 {
        unsafe { $($path_to_types)*:: _export_export_id_f32_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-f64")] unsafe extern "C" fn
        export_export_id_f64(arg0 : f64,) -> f64 { unsafe { $($path_to_types)*::
        _export_export_id_f64_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-bool")] unsafe extern "C" fn export_export_id_bool(arg0 : i32,) -> i32
        { unsafe { $($path_to_types)*:: _export_export_id_bool_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-char")] unsafe extern "C" fn
        export_export_id_char(arg0 : i32,) -> i32 { unsafe { $($path_to_types)*::
        _export_export_id_char_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-list-u8")] unsafe extern "C" fn export_export_id_list_u8(arg0 : * mut
        u8, arg1 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
        _export_export_id_list_u8_cabi::<$ty > (arg0, arg1) } } #[unsafe (export_name =
        "cabi_post_export-id-list-u8")] unsafe extern "C" fn
        _post_return_export_id_list_u8(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_export_id_list_u8::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-tuple-u8-string")] unsafe extern "C" fn
        export_export_id_tuple_u8_string(arg0 : i32, arg1 : * mut u8, arg2 : usize,) -> *
        mut u8 { unsafe { $($path_to_types)*::
        _export_export_id_tuple_u8_string_cabi::<$ty > (arg0, arg1, arg2) } } #[unsafe
        (export_name = "cabi_post_export-id-tuple-u8-string")] unsafe extern "C" fn
        _post_return_export_id_tuple_u8_string(arg0 : * mut u8,) { unsafe {
        $($path_to_types)*:: __post_return_export_id_tuple_u8_string::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-flags")] unsafe extern "C" fn
        export_export_id_flags(arg0 : i32,) -> i32 { unsafe { $($path_to_types)*::
        _export_export_id_flags_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-variant")] unsafe extern "C" fn export_export_id_variant(arg0 : i32,
        arg1 : * mut u8, arg2 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
        _export_export_id_variant_cabi::<$ty > (arg0, arg1, arg2) } } #[unsafe
        (export_name = "cabi_post_export-id-variant")] unsafe extern "C" fn
        _post_return_export_id_variant(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_export_id_variant::<$ty > (arg0) } } #[unsafe (export_name =
        "export-id-enum")] unsafe extern "C" fn export_export_id_enum(arg0 : i32,) -> i32
        { unsafe { $($path_to_types)*:: _export_export_id_enum_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-point")] unsafe extern "C" fn
        export_export_id_point(arg0 : i32, arg1 : i32,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_export_id_point_cabi::<$ty > (arg0, arg1) } }
        #[unsafe (export_name = "export-id-option-u8")] unsafe extern "C" fn
        export_export_id_option_u8(arg0 : i32, arg1 : i32,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_export_id_option_u8_cabi::<$ty > (arg0, arg1) } }
        #[unsafe (export_name = "export-id-result-u8-string")] unsafe extern "C" fn
        export_export_id_result_u8_string(arg0 : i32, arg1 : * mut u8, arg2 : usize,) ->
        * mut u8 { unsafe { $($path_to_types)*::
        _export_export_id_result_u8_string_cabi::<$ty > (arg0, arg1, arg2) } } #[unsafe
        (export_name = "cabi_post_export-id-result-u8-string")] unsafe extern "C" fn
        _post_return_export_id_result_u8_string(arg0 : * mut u8,) { unsafe {
        $($path_to_types)*:: __post_return_export_id_result_u8_string::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-result-u8-none")] unsafe extern "C" fn
        export_export_id_result_u8_none(arg0 : i32, arg1 : i32,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_export_id_result_u8_none_cabi::<$ty > (arg0, arg1) }
        } #[unsafe (export_name = "export-id-result-none-string")] unsafe extern "C" fn
        export_export_id_result_none_string(arg0 : i32, arg1 : * mut u8, arg2 : usize,)
        -> * mut u8 { unsafe { $($path_to_types)*::
        _export_export_id_result_none_string_cabi::<$ty > (arg0, arg1, arg2) } } #[unsafe
        (export_name = "cabi_post_export-id-result-none-string")] unsafe extern "C" fn
        _post_return_export_id_result_none_string(arg0 : * mut u8,) { unsafe {
        $($path_to_types)*:: __post_return_export_id_result_none_string::<$ty > (arg0) }
        } #[unsafe (export_name = "export-id-result-none-none")] unsafe extern "C" fn
        export_export_id_result_none_none(arg0 : i32,) -> i32 { unsafe {
        $($path_to_types)*:: _export_export_id_result_none_none_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "export-id-record-complex")] unsafe extern "C" fn
        export_export_id_record_complex(arg0 : * mut u8,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_export_id_record_complex_cabi::<$ty > (arg0) } }
        #[unsafe (export_name = "cabi_post_export-id-record-complex")] unsafe extern "C"
        fn _post_return_export_id_record_complex(arg0 : * mut u8,) { unsafe {
        $($path_to_types)*:: __post_return_export_id_record_complex::<$ty > (arg0) } }
        #[unsafe (export_name = "get-random-bytes")] unsafe extern "C" fn
        export_get_random_bytes(arg0 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
        _export_get_random_bytes_cabi::<$ty > (arg0) } } #[unsafe (export_name =
        "cabi_post_get-random-bytes")] unsafe extern "C" fn
        _post_return_get_random_bytes(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_get_random_bytes::<$ty > (arg0) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_root_cabi;
#[cfg_attr(target_pointer_width = "64", repr(align(8)))]
#[cfg_attr(target_pointer_width = "32", repr(align(4)))]
struct _RetArea(
    [::core::mem::MaybeUninit<u8>; 32 + 18 * ::core::mem::size_of::<*const u8>()],
);
static mut _RET_AREA: _RetArea = _RetArea(
    [::core::mem::MaybeUninit::uninit(); 32 + 18 * ::core::mem::size_of::<*const u8>()],
);
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn char_lift(val: u32) -> char {
        if cfg!(debug_assertions) {
            core::char::from_u32(val).unwrap()
        } else {
            core::char::from_u32_unchecked(val)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_root_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_root_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_root_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:component:component-type-conversions:root:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1947] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xa0\x0e\x01A\x02\x01\
Ac\x01r\x02\x01xy\x01yy\x03\0\x05point\x03\0\0\x01m\x03\x01a\x01b\x01c\x03\0\x09\
enum-type\x03\0\x02\x01p\x01\x01k}\x01q\x09\x04none\0\0\x03str\x01s\0\x03int\x01\
y\0\x05float\x01v\0\x07boolean\x01\x7f\0\x05point\x01\x01\0\x0alist-point\x01\x04\
\0\x09option-u8\x01\x05\0\x09enum-type\x01\x03\0\x03\0\x0cvariant-type\x03\0\x06\
\x01n\x03\x04read\x05write\x04exec\x03\0\x0apermission\x03\0\x08\x01p}\x01ks\x01\
k\x01\x01k\x04\x01j\x01}\x01s\x01j\0\0\x01o\x02}\x01\x01r\x0d\x03strs\x03inty\x05\
floatv\x07boolean\x7f\x07list-u8\x0a\x0alist-point\x04\x09option-u8\x05\x0doptio\
n-string\x0b\x0coption-point\x0c\x11option-list-point\x0d\x10result-u8-string\x0e\
\x0cempty-result\x0f\x0etuple-u8-point\x10\x03\0\x0ccomplex-type\x03\0\x11\x01@\x01\
\x03strs\0s\x03\0\x10import-id-string\x01\x13\x01@\x01\x03int}\0}\x03\0\x0cimpor\
t-id-u8\x01\x14\x01@\x01\x03int{\0{\x03\0\x0dimport-id-u16\x01\x15\x01@\x01\x03i\
nty\0y\x03\0\x0dimport-id-u32\x01\x16\x01@\x01\x03intw\0w\x03\0\x0dimport-id-u64\
\x01\x17\x01@\x01\x03int~\0~\x03\0\x0cimport-id-s8\x01\x18\x01@\x01\x03int|\0|\x03\
\0\x0dimport-id-s16\x01\x19\x01@\x01\x03intz\0z\x03\0\x0dimport-id-s32\x01\x1a\x01\
@\x01\x03intx\0x\x03\0\x0dimport-id-s64\x01\x1b\x01@\x01\x05floatv\0v\x03\0\x0di\
mport-id-f32\x01\x1c\x01@\x01\x05floatu\0u\x03\0\x0dimport-id-f64\x01\x1d\x01@\x01\
\x07boolean\x7f\0\x7f\x03\0\x0eimport-id-bool\x01\x1e\x01@\x01\x03chrt\0t\x03\0\x0e\
import-id-char\x01\x1f\x01@\x01\x01l\x0a\0\x0a\x03\0\x11import-id-list-u8\x01\x20\
\x01o\x02}s\x01@\x01\x01t!\0!\x03\0\x19import-id-tuple-u8-string\x01\"\x01@\x01\x01\
f\x09\0\x09\x03\0\x0fimport-id-flags\x01#\x01@\x01\x01v\x07\0\x07\x03\0\x11impor\
t-id-variant\x01$\x01@\x01\x01e\x03\0\x03\x03\0\x0eimport-id-enum\x01%\x01@\x01\x01\
p\x01\0\x01\x03\0\x0fimport-id-point\x01&\x01@\x01\x01o\x05\0\x05\x03\0\x13impor\
t-id-option-u8\x01'\x01@\x01\x01r\x0e\0\x0e\x03\0\x1aimport-id-result-u8-string\x01\
(\x01j\x01}\0\x01@\x01\x01r)\0)\x03\0\x18import-id-result-u8-none\x01*\x01j\0\x01\
s\x01@\x01\x01r+\0+\x03\0\x1cimport-id-result-none-string\x01,\x01@\x01\x01r\x0f\
\0\x0f\x03\0\x1aimport-id-result-none-none\x01-\x01@\x01\x01r\x12\0\x12\x03\0\x18\
import-id-record-complex\x01.\x04\0\x10export-id-string\x01\x13\x04\0\x0cexport-\
id-u8\x01\x14\x04\0\x0dexport-id-u16\x01\x15\x04\0\x0dexport-id-u32\x01\x16\x04\0\
\x0dexport-id-u64\x01\x17\x04\0\x0cexport-id-s8\x01\x18\x04\0\x0dexport-id-s16\x01\
\x19\x04\0\x0dexport-id-s32\x01\x1a\x04\0\x0dexport-id-s64\x01\x1b\x04\0\x0dexpo\
rt-id-f32\x01\x1c\x04\0\x0dexport-id-f64\x01\x1d\x04\0\x0eexport-id-bool\x01\x1e\
\x04\0\x0eexport-id-char\x01\x1f\x04\0\x11export-id-list-u8\x01\x20\x04\0\x19exp\
ort-id-tuple-u8-string\x01\"\x04\0\x0fexport-id-flags\x01#\x04\0\x11export-id-va\
riant\x01$\x04\0\x0eexport-id-enum\x01%\x04\0\x0fexport-id-point\x01&\x04\0\x13e\
xport-id-option-u8\x01'\x04\0\x1aexport-id-result-u8-string\x01(\x04\0\x18export\
-id-result-u8-none\x01*\x04\0\x1cexport-id-result-none-string\x01,\x04\0\x1aexpo\
rt-id-result-none-none\x01-\x04\0\x18export-id-record-complex\x01.\x01@\x01\x03l\
eny\0\x0a\x04\0\x10get-random-bytes\x01/\x04\0)component:component-type-conversi\
ons/root\x04\0\x0b\x0a\x01\0\x04root\x03\0\0\0G\x09producers\x01\x0cprocessed-by\
\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
